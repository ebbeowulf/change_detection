#A set of routines for processing the images.txt file generated by colmap
import numpy as np
from scipy.spatial.transform import Rotation as R
import pdb

def get_world_pose(trans, quat):
    mm=np.identity(4)
    mm[:3,:3]=R.from_quat(quat).as_matrix()
    # mm=tf.transformations.quaternion_matrix(quat)
    mmT=np.transpose(mm)
    pose=np.matmul(-mmT[:3,:3],trans)
    mmT[:3,3]=pose
    return pose, mmT
    
def is_number(val:str):
    try:
        val_f=float(str)
        return True
    except Exception as e:
        return False

def read_image_csv(images_txt):
    with open(images_txt,"r") as fin:
        A=fin.readlines()

    all_images={}
    for ln_ in A:
        try:
            if len(ln_)<2:
                continue
            if ln_[-1]=='\n':
                ln_=ln_[:-1]
            if ln_[0]=='#':
                continue
            if ',' in ln_:
                ln_s=ln_.split(', ')
            else:
                ln_s=ln_.split(' ')

            # We will assume a format of {rootname}_{image_id}.png in the image name
            id_str=ln_s[-1].split('_')[-1].split('.')[0]
            id=int(id_str)
            quat=[float(ln_s[2]),float(ln_s[3]), float(ln_s[4]), float(ln_s[1])]
            trans=[float(ln_s[5]),float(ln_s[6]),float(ln_s[7])]
            world_pose, rotM = get_world_pose(trans, quat)
            directory=ln_s[-2]
            if is_number(directory):
                directory=''
            
            image={'rot': quat, 'trans': trans, 'id': id, 'global_pose': world_pose, 'global_poseM': rotM, 'name': ln_s[-1], 'directory': directory}
            all_images[image['directory']+image['name']]=image
        except Exception as e:
            print("Error adding image: " + ln_)
    return all_images

def dist(A:np.array):
    return np.sqrt(np.power(A,2).sum())

class image_set():
    def __init__(self, images_csv:str):
        self.all_images = read_image_csv(images_csv)

    def get_pose_list(self):
        return list(self.all_images.keys())
    
    def get_pose_by_name(self, directory, name):
        key=directory+name
        if key in self.all_images:
            return self.all_images[key]['global_poseM']
        return None

    def get_pose_by_id(self, id):
        for key in self.all_images.keys():
            if self.all_images[key]['id']==id:
                return self.all_images[key]['global_poseM']
        return None

    def get_related_poses(self, 
                          tgt_obj_pose:np.array, 
                          max_angle:float=0.5, 
                          min_dist=0.5):
        im_list=[]
        for key in self.all_images.keys():
            im = self.all_images[key]
            # Filter Images by Distance from Target
            deltaD=dist(tgt_obj_pose-im['global_pose'])
            if deltaD<min_dist:
                continue

            forward=np.matmul(im['global_poseM'][:3,:3],[0,0,1.0])
            actual=tgt_obj_pose-im['global_pose']
            angle=np.arccos(np.dot(forward,actual)/(dist(forward)*dist(actual)))
            if np.fabs(angle)<max_angle:
                im_list.append(key)

        return im_list
    
    def get_dir_and_name(self, value):
        if value in self.all_images:
            key=value
        else:
            for kk in self.all_images:
                if self.all_images[kk]['id']==kk:
                    key=kk
                    break
        if key in self.all_images:
            return self.all_images[key]['directory'],self.all_images[key]['name']
        return None

    def get_all_poses(self, sort_by_id=False):
        arr = []
        ids = []
        for key in self.all_images.keys():
            arr.append(self.all_images[key]['global_pose'])
            ids.append(self.all_images[key]['id'])
        if sort_by_id:
            rr=np.argsort(ids)
            arr=np.array(arr)[rr]
            return arr
        else:
            return np.array(arr)
    
    def get_nearest_pose_by_angle(self, 
                                  tgt_obj_pose: np.array, 
                                  tgt_camera_poseM: np.ndarray, 
                                  max_tgt_angle=0.5,
                                  min_dist_pct=0.8):        
        # We are going to use the tgt_obj_pose as a distance marker
        #   any selected image needs to be no closer than 90% of the way
        min_dist=min_dist_pct*dist(tgt_obj_pose-tgt_camera_poseM[:3,3])
        im_list=self.get_related_poses(tgt_obj_pose, max_tgt_angle, min_dist)

        # Second - find the pose with the closest camera angle in global coordinates
        forward=np.array([0,0,1.0],dtype=float)
        tgt_vec=np.matmul(tgt_camera_poseM[:3,:3], forward)
        dTgt=dist(tgt_vec)
        best_angle=np.pi
        best_key = None
        for key in im_list:
            im_vec=np.matmul(self.all_images[key]['global_poseM'][:3,:3],forward)
            im_angle=np.arccos(np.dot(tgt_vec,im_vec)/(dTgt*dist(im_vec)))
            if np.abs(im_angle)<best_angle:
                best_key=key
                best_angle=np.abs(im_angle)
        
        return best_key

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('images_txt',type=str,help='location of colmap images.txt file to process')
    args = parser.parse_args()

    img_set=image_set(args.images_txt)
    all_poses=img_set.get_all_poses(sort_by_id=True)

    import matplotlib.pyplot as plt    
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(all_poses[:,0], all_poses[:,1], all_poses[:,2])
    plt.show()  

